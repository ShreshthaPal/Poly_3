zardkat
A hardhat-circom template to generate zero-knowledge circuits, proofs, and solidity verifiers

Quick Start
Compile the Circuit1() circuit and verify it against a smart contract verifier

pragma circom 2.0.0;

/*This circuit template checks that c is the multiplication of a and b.*/  

template Circuit1 () {  

   // Declaration of signals.  
   signal input a;  
   signal input b;  
   signal output c;  

   // Constraints.  
   c <== a * b;  
}
component main = Circuit1();
Install
npm i

Compile
npx hardhat circom This will generate the out file with circuit intermediaries and geneate the Circuit1Verifier.sol contract

Prove and Deploy
npx hardhat run scripts/deploy.ts This script does 4 things

Deploys the Circuit1Verifier.sol contract
Generates a proof from circuit intermediaries with generateProof()
Generates calldata with generateCallData()
Calls verifyProof() on the verifier contract with calldata
With two commands you can compile a ZKP, generate a proof, deploy a verifier, and verify the proof ðŸŽ‰

Configuration
Directory Structure
circuits

â”œâ”€â”€ Circuit1
â”‚   â”œâ”€â”€ circuit.circom
â”‚   â”œâ”€â”€ input.json
â”‚   â””â”€â”€ out
â”‚       â”œâ”€â”€ circuit.wasm
â”‚       â”œâ”€â”€ Circuit1.r1cs
â”‚       â”œâ”€â”€ Circuit1.vkey
â”‚       â””â”€â”€ Circuit1.zkey
â”œâ”€â”€ new-circuit
â””â”€â”€ powersOfTau28_hez_final_12.ptau
Each new circuit lives in it's own directory. At the top level of each circuit directory lives the circom circuit and input to the circuit. The out directory will be autogenerated and store the compiled outputs, keys, and proofs. The Powers of Tau file comes from the Polygon Hermez ceremony, which saves time by not needing a new ceremony.

contracts

contracts
â””â”€â”€ Circuit1Verifier.sol
Verifier contracts are autogenerated and prefixed by the circuit name, in this example Circuit1

hardhat.config.ts
  circom: {
    // (optional) Base path for input files, defaults to `./circuits/`
    inputBasePath: "./circuits",
    // (required) The final ptau file, relative to inputBasePath, from a Phase 1 ceremony
    ptau: "powersOfTau28_hez_final_12.ptau",
    // (required) Each object in this array refers to a separate circuit
    circuits: JSON.parse(JSON.stringify(circuits))
  },
circuits.config.json
circuits configuation is separated from hardhat.config.ts for autogenerated purposes (see next section)

[
  {
    "name": "Circuit1",
    "protocol": "groth16",
    "circuit": "Circuit1/circuit.circom",
    "input": "Circuit1/input.json",
    "wasm": "Circuit1/out/circuit.wasm",
    "zkey": "Circuit1/out/Circuit1.zkey",
    "vkey": "Circuit1/out/Circuit1.vkey",
    "r1cs": "Circuit1/out/Circuit1.r1cs",
    "beacon": "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
  }
]
adding circuits
To add a new circuit, you can run the newcircuit hardhat task to autogenerate configuration and directories i.e

npx hardhat newcircuit --name newcircuit
determinism

description:-

Circuit Template: The circuit template is named circom2 and has no input arguments.

Signal Inputs: The template defines two input signals, A and B. These signals are the inputs to the circuit, and their values are provided externally when the circuit is used.

Signals from Gates: The template defines two signals, X and Y, which will hold the intermediate results of the circuit's logic.

Final Signal Output: The template declares an output signal Q, which represents the final output of the circuit. The purpose of this circuit is to verify if Q is the multiplication of A and B.

Component Gates: The template defines three custom component gates: andGate, notgate, and norGate. These component gates are used to create the custom logic for this circuit.

Circuit Logic: The circuit logic consists of connecting the inputs and outputs of the component gates in a specific manner:

andGate takes inputs A and B, performs the AND operation on them, and outputs the result to signal X.
notgate takes input B, performs the NOT operation on it, and outputs the result to signal Y.
norGate takes inputs X and Y, performs the NOR operation on them, and outputs the result to signal Q.
Template for AND: The template named AND defines an AND gate with two input signals A and B and an output signal out. The AND gate simply multiplies A and B together and assigns the result to out.

Template for NOT: The template named NOT defines a NOT gate with one input signal in and one output signal out. The NOT gate inverts the input signal by subtracting it from 1.

Template for NOR: The template named NOR defines a NOR gate with two input signals X and Y and an output signal out. The NOR gate implements the logical NOR operation, which is the inverse of the OR operation. The result is 1 if both X and Y are 0; otherwise, the result is 0.

Component Main: Finally, the main component is created using the circom2 template, indicating that this is the main circuit to be used.

AUTHOR:
SHRESHTHA PAL

License
This project is licensed under the MIT License - see the LICENSE file for details.
